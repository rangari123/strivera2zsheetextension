<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Questions Table</title>
</head>

<body>
    <h1>DSA Questions</h1>
    <table border="1">
        <tr>
            <th>Question</th>
            <th>Topic</th>
            <th>Tags</th>
        </tr>
        <tr>
            <td>Understand recursion by printing something N times</td>
            <td>Recursion</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Print name N times using recursion</td>
            <td>Recursion</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Print 1 to N using recursion</td>
            <td>Recursion</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Print N to 1 using recursion</td>
            <td>Recursion</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Sum of first N numbers</td>
            <td>Recursion</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Factorial of N numbers</td>
            <td>Recursion</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Reverse an array</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Check if a string is palindrome or not</td>
            <td>Strings</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Fibonacci Number</td>
            <td>Recursion</td>
            <td>Easy</td>
        </tr>
        <!-- Hashing Questions -->
        <tr>
            <td>Hashing Theory</td>
            <td>Hashing</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Counting frequencies of array elements</td>
            <td>Hashing</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Find the highest/lowest frequency element</td>
            <td>Hashing</td>
            <td>Easy</td>
        </tr>
        <!-- Sorting Questions -->
        <tr>
            <td>Selection Sort</td>
            <td>Sorting</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Bubble Sort</td>
            <td>Sorting</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Insertion Sort</td>
            <td>Sorting</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Merge Sort</td>
            <td>Sorting</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Recursive Bubble Sort</td>
            <td>Sorting</td>
            <td>Soon...</td>
        </tr>
        <tr>
            <td>Recursive Insertion Sort</td>
            <td>Sorting</td>
            <td>Soon...</td>
        </tr>
        <tr>
            <td>Quick Sort</td>
            <td>Sorting</td>
            <td>Easy</td>
        </tr>
        <!-- Array Questions -->
        <tr>
            <td>Largest Element in an Array</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Second Largest Element in an Array without sorting</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Check if the array is sorted</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Remove duplicates from Sorted array</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Left Rotate an array by one place</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Left rotate an array by D places</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Move Zeros to end</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Linear Search</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Find the Union</td>
            <td>Arrays</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find missing number in an array</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Maximum Consecutive Ones</td>
            <td>Arrays</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Find the number that appears once, and other numbers twice</td>
            <td>Arrays</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Longest subarray with given sum K (positives)</td>
            <td>Arrays</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Longest subarray with sum K (Positives + Negatives)</td>
            <td>Arrays</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>2Sum Problem</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Sort an array of 0's 1's and 2's</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Majority Element (&gt;n/2 times)</td>
            <td>Array</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Kadane's Algorithm, maximum subarray sum</td>
            <td>Array</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Print subarray with maximum subarray sum (extended version of above problem)</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Stock Buy and Sell</td>
            <td>Array</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Rearrange the array in alternating positive and negative items</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Next Permutation</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Leaders in an Array problem</td>
            <td>Array</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Longest Consecutive Sequence in an Array</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Set Matrix Zeros</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Rotate Matrix by 90 degrees</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Print the matrix in spiral manner</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Count subarrays with given sum</td>
            <td>Array</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Pascal's Triangle</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Majority Element (n/3 times)</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>3-Sum Problem</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>4-Sum Problem</td>
            <td>Array</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Largest Subarray with 0 Sum</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Count number of subarrays with given xor K</td>
            <td>Array</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Merge Overlapping Subintervals</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Merge two sorted arrays without extra space</td>
            <td>Array</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find the repeating and missing number</td>
            <td>Array</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Count Inversions</td>
            <td>Array</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Reverse Pairs</td>
            <td>Array</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Maximum Product Subarray</td>
            <td>Array</td>
            <td>Easy</td>
        </tr>

        <tr>
            <td>Binary Search to find X in sorted array</td>
            <td>Binary Search</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Implement Lower Bound</td>
            <td>Binary Search</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Implement Upper Bound</td>
            <td>Binary Search</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Search Insert Position</td>
            <td>Binary Search</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Floor/Ceil in Sorted Array</td>
            <td>Binary Search</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find the first or last occurrence of a given number in a sorted array</td>
            <td>Binary Search</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Count occurrences of a number in a sorted array with duplicates</td>
            <td>Binary Search</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Search in Rotated Sorted Array I</td>
            <td>Binary Search</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Search in Rotated Sorted Array II</td>
            <td>Binary Search</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find minimum in Rotated Sorted Array</td>
            <td>Binary Search</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find out how many times has an array been rotated</td>
            <td>Binary Search</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Single element in a Sorted Array</td>
            <td>Binary Search</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Find peak element</td>
            <td>Binary Search</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Find square root of a number in log n</td>
            <td>Binary Search</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find the Nth root of a number using binary search</td>
            <td>Binary Search</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Koko Eating Bananas</td>
            <td>Binary Search</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Minimum days to make M bouquets</td>
            <td>Binary Search</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Find the smallest Divisor</td>
            <td>Binary Search</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Capacity to Ship Packages within D Days</td>
            <td>Binary Search</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Kth Missing Positive Number</td>
            <td>Binary Search</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Aggressive Cows</td>
            <td>Binary Search</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Book Allocation Problem</td>
            <td>Binary Search</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Split array - Largest Sum</td>
            <td>Binary Search</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Painter's partition code</td>
            <td>Binary Search</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Minimize Max Distance to Gas Station</td>
            <td>Binary Search</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Median of 2 sorted arrays</td>
            <td>Binary Search</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Kth element of 2 sorted arrays</td>
            <td>Binary Search</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find the row with maximum number of 1's</td>
            <td>Matrix</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Search in a 2 D matrix</td>
            <td>Matrix</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Search in a row and column wise sorted matrix</td>
            <td>Matrix</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find Peak Element (2D Matrix)</td>
            <td>Matrix</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Matrix Median</td>
            <td>Matrix</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Remove outermost Paranthesis</td>
            <td>String</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Reverse words in a given string / Palindrome Check</td>
            <td>String</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Largest odd number in a string</td>
            <td>String</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Longest Common Prefix</td>
            <td>String</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Isomorphic String</td>
            <td>String</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Check whether one string is a rotation of another</td>
            <td>String</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Check if two strings are anagram of each other</td>
            <td>String</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Sort Characters by frequency</td>
            <td>String</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Maximum Nesting Depth of Paranthesis</td>
            <td>String</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Roman Number to Integer and vice versa</td>
            <td>String</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Implement Atoi</td>
            <td>String</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Count Number of Substrings</td>
            <td>String</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Longest Palindromic Substring[Do it without DP]</td>
            <td>String</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Sum of Beauty of all substring</td>
            <td>String</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Reverse Every Word in A String</td>
            <td>String</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Introduction to LinkedList</td>
            <td>LinkedList</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Inserting a node in LinkedList</td>
            <td>LinkedList</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Deleting a node in LinkedList</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find the length of the linkedlist [learn traversal]</td>
            <td>LinkedList</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Search an element in the LL</td>
            <td>LinkedList</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Introduction to DLL</td>
            <td>DLL</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Insert a node in DLL</td>
            <td>DLL</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Delete a node in DLL</td>
            <td>DLL</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Reverse a DLL</td>
            <td>DLL</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Middle of a LinkedList [TortoiseHare Method]</td>
            <td>LinkedList</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Reverse a LinkedList [Iterative]</td>
            <td>LinkedList</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Reverse a LL [Recursive]</td>
            <td>LinkedList</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Detect a loop in LL</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find the starting point in LL</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Length of Loop in LL</td>
            <td>LinkedList</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Check if LL is palindrome or not</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Segrregate odd and even nodes in LL</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Remove Nth node from the back of the LL</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Delete the middle node of LL</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Sort LL</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Sort a LL of 0's 1's and 2's by changing links</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find the intersection point of Y LL</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Add 1 to a number represented by LL</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Add 2 numbers in LL</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>

        <tr>
            <td>Delete all occurrences of a key in DLL</td>
            <td>DLL</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find pairs with given sum in DLL</td>
            <td>DLL</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Remove duplicates from sorted DLL</td>
            <td>DLL</td>
            <td>Medium</td>
        </tr>

        <tr>
            <td>Reverse LL in group of given size K</td>
            <td>LinkedList</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Rotate a LL</td>
            <td>LinkedList</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Flattening of LL</td>
            <td>LinkedList</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Clone a Linked List with random and next pointer</td>
            <td>LinkedList</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Recursive Implementation of atoi()</td>
            <td>Recursion</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Pow(x, n)</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Count Good numbers</td>
            <td>Recursion</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Sort a stack using recursion</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Reverse a stack using recursion</td>
            <td>Recursion</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Generate all binary strings</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Generate Paranthesis</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Print all subsequences/Power Set</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Learn All Patterns of Subsequences (Theory)</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Count all subsequences with sum K</td>
            <td>Recursion</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Check if there exists a subsequence with sum K</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Combination Sum</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Combination Sum-II</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Subset Sum-I</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Subset Sum-II</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Combination Sum - III</td>
            <td>Recursion</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Letter Combinations of a Phone number</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Palindrome Partitioning</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Word Search</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>N Queen</td>
            <td>Recursion</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Rat in a Maze</td>
            <td>Recursion</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Word Break</td>
            <td>Recursion</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>M Coloring Problem</td>
            <td>Recursion</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Sudoku Solver</td>
            <td>Recursion</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Expression Add Operators</td>
            <td>Recursion</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Introduction to Bit Manipulation [Theory]</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Check if the i-th bit is set or not</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Check if a number is odd or not</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Check if a number is power of 2 or not</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Count the number of set bits</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Set/Unset the rightmost unset bit</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Swap two numbers</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Divide two integers without using multiplication, division and mod operator</td>
            <td>Bit Manipulation</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Count number of bits to be flipped to convert A to B</td>
            <td>Bit Manipulation</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find the number that appears odd number of times</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Power Set</td>
            <td>Bit Manipulation</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find xor of numbers from L to R</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Find the two numbers appearing odd number of times</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Print Prime Factors of a Number</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>All Divisors of a Number</td>
            <td>Bit Manipulation</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Sieve of Eratosthenes</td>
            <td>Bit Manipulation</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find Prime Factorisation of a Number using Sieve</td>
            <td>Bit Manipulation</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Power(n, x)</td>
            <td>Bit Manipulation</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Implement Stack using Arrays</td>
            <td>Stack and Queue</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Implement Queue using Arrays</td>
            <td>Stack and Queue</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Implement Stack using Queue</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Implement Queue using Stack</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Implement stack using Linkedlist</td>
            <td>Stack and Queue</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Implement queue using Linkedlist</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Check for balanced paranthesis</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Implement Min Stack</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Infix to Postfix Conversion using Stack</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Prefix to Infix Conversion</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Prefix to Postfix Conversion</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Postfix to Prefix Conversion</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Postfix to Infix</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Convert Infix To Prefix Notation</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Next Greater Element</td>
            <td>Stack and Queue</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Next Greater Element 2</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Next Smaller Element</td>
            <td>Stack and Queue</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Number of NGEs to the right</td>
            <td>Stack and Queue</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Trapping Rainwater</td>
            <td>Stack and Queue</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Sum of subarray minimum</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Asteroid Collision</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Sum of subarray ranges</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Remove k Digits</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Largest rectangle in a histogram</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Maximal Rectangles</td>
            <td>Stack and Queue</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Sliding Window maximum</td>
            <td>Stack and Queue</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Stock span problem</td>
            <td>Stack and Queue</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>The Celebrity Problem</td>
            <td>Stack and Queue</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>LRU cache (IMPORTANT)</td>
            <td>Stack and Queue</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>LFU cache</td>
            <td>Stack and Queue</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Longest Substring Without Repeating Characters</td>
            <td>Sliding Window</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Max Consecutive Ones III</td>
            <td>Sliding Window</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Fruit Into Baskets</td>
            <td>Sliding Window</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Longest Repeating Character Replacement</td>
            <td>Sliding Window</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Binary Subarray with Sum</td>
            <td>Sliding Window</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Count Number of Nice Subarrays</td>
            <td>Sliding Window</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Number of Substrings Containing All Three Characters</td>
            <td>Sliding Window</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Maximum Point You Can Obtain from Cards</td>
            <td>Sliding Window</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Longest Substring with At Most K Distinct Characters</td>
            <td>Sliding Window</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Subarray with K Different Integers</td>
            <td>Sliding Window</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Minimum Window Substring</td>
            <td>Sliding Window</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Minimum Window Subsequence</td>
            <td>Sliding Window</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Introduction to Priority Queues using Binary Heaps</td>
            <td>Heap</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Min Heap and Max Heap Implementation</td>
            <td>Heap</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Check if an array represents a min-heap or not</td>
            <td>Heap</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Convert min Heap to max Heap</td>
            <td>Heap</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Kth largest element in an array [use priority queue]</td>
            <td>Heap</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Kth smallest element in an array [use priority queue]</td>
            <td>Heap</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Sort K sorted array</td>
            <td>Heap</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Merge M sorted Lists</td>
            <td>Heap</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Replace each array element by its corresponding rank</td>
            <td>Heap</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Task Scheduler</td>
            <td>Heap</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Hands of Straights</td>
            <td>Heap</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Design twitter</td>
            <td>Heap</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Connect `n` ropes with minimal cost</td>
            <td>Heap</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Kth largest element in a stream of running integers</td>
            <td>Heap</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Maximum Sum Combination</td>
            <td>Heap</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find Median from Data Stream</td>
            <td>Heap</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>K most frequent elements</td>
            <td>Heap</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Assign Cookies</td>
            <td>Greedy</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Lemonade Change</td>
            <td>Greedy</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Fractional Knapsack Problem</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Greedy algorithm to find minimum number of coins</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Valid Paranthesis Checker</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>N meetings in one room</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Jump Game</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Jump Game 2</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Minimum number of platforms required for a railway</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Job sequencing Problem</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Candy</td>
            <td>Greedy</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Program for Shortest Job First (or SJF) CPU Scheduling</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Program for Least Recently Used (LRU) Page Replacement Algorithm</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Insert Interval</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Merge Intervals</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Non-overlapping Intervals</td>
            <td>Greedy</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Introduction to Trees</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Binary Tree Representation in C++</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Binary Tree Representation in Java</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Binary Tree Traversals in Binary Tree</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Preorder Traversal of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Inorder Traversal of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Post-order Traversal of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Level order Traversal / Level order traversal in spiral form</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Iterative Preorder Traversal of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Iterative Inorder Traversal of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Post-order Traversal of Binary Tree using 2 stack</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Post-order Traversal of Binary Tree using 1 stack</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Preorder, Inorder, and Postorder Traversal in one Traversal</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Height of a Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Check if the Binary tree is height-balanced or not</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Diameter of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Maximum path sum</td>
            <td>Binary Trees</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Check if two trees are identical or not</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Zig Zag Traversal of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Boundary Traversal of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Vertical Order Traversal of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Top View of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Bottom View of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Right/Left View of Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Symmetric Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Root to Node Path in Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>LCA in Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Maximum width of a Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Check for Children Sum Property</td>
            <td>Binary Trees</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Print all the Nodes at a distance of K in a Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Minimum time taken to BURN the Binary Tree from a Node</td>
            <td>Binary Trees</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Count total Nodes in a COMPLETE Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Requirements needed to construct a Unique Binary Tree | Theory</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Construct Binary Tree from inorder and preorder</td>
            <td>Binary Trees</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Construct the Binary Tree from Postorder and Inorder Traversal</td>
            <td>Binary Trees</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Serialize and deserialize Binary Tree</td>
            <td>Binary Trees</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Morris Preorder Traversal of a Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Morris Inorder Traversal of a Binary Tree</td>
            <td>Binary Trees</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Flatten Binary Tree to LinkedList</td>
            <td>Binary Trees</td>
            <td>Hard</td>
        </tr>
        <tr>
            <th>Problem</th>
            <th>Topic</th>
            <th>Difficulty</th>
        </tr>
        <!-- Easy Problems -->
        <tr>
            <td>Introduction to Binary Search Tree</td>
            <td>Binary Search Tree</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Search in a Binary Search Tree</td>
            <td>Binary Search Tree</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Ceil in a Binary Search Tree</td>
            <td>Binary Search Tree</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Floor in a Binary Search Tree</td>
            <td>Binary Search Tree</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Insert a given Node in Binary Search Tree</td>
            <td>Binary Search Tree</td>
            <td>Easy</td>
        </tr>

        <!-- Medium Problems -->
        <tr>
            <td>Find Min/Max in BST</td>
            <td>Binary Search Tree</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Delete a Node in Binary Search Tree</td>
            <td>Binary Search Tree</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Find K-th smallest/largest element in BST</td>
            <td>Binary Search Tree</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Check if a tree is a BST or BT</td>
            <td>Binary Search Tree</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>LCA in Binary Search Tree</td>
            <td>Binary Search Tree</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Construct a BST from a preorder traversal</td>
            <td>Binary Search Tree</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Inorder Successor/Predecessor in BST</td>
            <td>Binary Search Tree</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Two Sum In BST | Check if there exists a pair with Sum K</td>
            <td>Binary Search Tree</td>
            <td>Medium</td>
        </tr>

        <!-- Hard Problems -->
        <tr>
            <td>Merge 2 BST's</td>
            <td>Binary Search Tree</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Recover BST | Correct BST with two nodes swapped</td>
            <td>Binary Search Tree</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Largest BST in Binary Tree</td>
            <td>Binary Search Tree</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Graph and Types</td>
            <td>Graphs</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Graph Representation | C++</td>
            <td>Graphs</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Graph Representation | Java</td>
            <td>Graphs</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>Connected Components | Logic Explanation</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>BFS</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>DFS</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>

        <!-- Lec 2: Problems on BFS/DFS -->
        <tr>
            <td>Number of provinces (leetcode)</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Connected Components Problem in Matrix</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Rotten Oranges</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Flood fill</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Cycle Detection in undirected Graph (bfs)</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Cycle Detection in undirected Graph (dfs)</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>0/1 Matrix (Bfs Problem)</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Surrounded Regions (dfs)</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Number of Enclaves [flood fill implementation - multisource]</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Word ladder - 1</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Word ladder - 2</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Number of Distinct Islands [dfs multisource]</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Bipartite Graph (DFS)</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Cycle Detection in Directed Graph (DFS)</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>

        <!-- Lec 3: Topo Sort and Problems -->
        <tr>
            <td>Topo Sort</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Kahn's Algorithm</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Cycle Detection in Directed Graph (BFS)</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Course Schedule - I</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Course Schedule - II</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Find eventual safe states</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Alien dictionary</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>

        <!-- Lec 4: Shortest Path Algorithms and Problems -->
        <tr>
            <td>Shortest Path in UG with unit weights</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Shortest Path in DAG</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Djisktra's Algorithm</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Why priority Queue is used in Djisktra's Algorithm</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Shortest path in a binary maze</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Path with minimum effort</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Cheapest flights within k stops</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Network Delay time</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Number of ways to arrive at destination</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Minimum steps to reach end from start by performing multiplication and mod operations with array
                elements</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Bellman Ford Algorithm</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Floyd Warshal Algorithm</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Find the city with the smallest number of neighbors in a threshold distance</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>

        <!-- Lec 5: MinimumSpanningTree/Disjoint Set and Problems -->
        <tr>
            <td>Minimum Spanning Tree</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Prim's Algorithm</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Disjoint Set [Union by Rank]</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Disjoint Set [Union by Size]</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Kruskal's Algorithm</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Number of operations to make network connected</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Most stones removed with same rows or columns</td>
            <td>Graphs</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Accounts merge</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Number of island II</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Making a Large Island</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Swim in rising water</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>

        <!-- Lec 6: Other Algorithms -->
        <tr>
            <td>Bridges in Graph</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Articulation Point</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Kosaraju's Algorithm</td>
            <td>Graphs</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Dynamic Programming Introduction</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>

        <!-- Lec 2: 1D DP -->
        <tr>
            <td>Climbing Stars</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Frog Jump(DP-3)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Frog Jump with k distances(DP-4)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Maximum sum of non-adjacent elements (DP 5)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>House Robber (DP 6)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>

        <!-- Lec 3: 2D/3D DP and DP on Grids -->
        <tr>
            <td>Ninja's Training (DP 7)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Grid Unique Paths : DP on Grids (DP8)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Grid Unique Paths 2 (DP 9)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Minimum path sum in Grid (DP 10)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Minimum path sum in Triangular Grid (DP 11)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Minimum/Maximum Falling Path Sum (DP-12)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>3-d DP : Ninja and his friends (DP-13)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>

        <!-- Lec 4: DP on Subsequences -->
        <tr>
            <td>Subset sum equal to target (DP- 14)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Partition Equal Subset Sum (DP- 15)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Partition Set Into 2 Subsets With Min Absolute Sum Diff (DP- 16)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Count Subsets with Sum K (DP - 17)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Count Partitions with Given Difference (DP - 18)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Assign Cookies</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Minimum Coins (DP - 20)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Target Sum (DP - 21)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Coin Change 2 (DP - 22)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Unbounded Knapsack (DP - 23)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Rod Cutting Problem | (DP - 24)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>

        <!-- Lec 5: DP on Strings -->
        <tr>
            <td>Longest Common Subsequence | (DP - 25)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Print Longest Common Subsequence | (DP - 26)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Longest Common Substring | (DP - 27)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Longest Palindromic Subsequence | (DP-28)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Minimum insertions to make string palindrome | DP-29</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Minimum Insertions/Deletions to Convert String | (DP- 30)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Shortest Common Supersequence | (DP - 31)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Distinct Subsequences| (DP-32)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Edit Distance | (DP-33)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Wildcard Matching | (DP-34)</td>
            <td>DP</td>
            <td>Medium</td>
        </tr>

        <!-- Lec 6: DP on Stocks -->
        <tr>
            <td>Best Time to Buy and Sell Stock |(DP-35)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Buy and Sell Stock - II|(DP-36)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Buy and Sell Stocks III|(DP-37)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Buy and Stock Sell IV |(DP-38)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Buy and Sell Stocks With Cooldown|(DP-39)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Buy and Sell Stocks With Transaction Fee|(DP-40)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>

        <!-- Lec 7: DP on LIS -->
        <tr>
            <td>Longest Increasing Subsequence |(DP-41)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Printing Longest Increasing Subsequence|(DP-42)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Longest Increasing Subsequence |(DP-43)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Largest Divisible Subset|(DP-44)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Longest String Chain|(DP-45)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Longest Bitonic Subsequence |(DP-46)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Number of Longest Increasing Subsequences|(DP-47)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>

        <!-- Lec 8: MCM DP | Partition DP -->
        <tr>
            <td>Matrix Chain Multiplication|(DP-48)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Matrix Chain Multiplication | Bottom-Up|(DP-49)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Minimum Cost to Cut the Stick|(DP-50)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Burst Balloons|(DP-51)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Evaluate Boolean Expression to True|(DP-52)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Palindrome Partitioning - II|(DP-53)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Partition Array for Maximum Sum|(DP-54)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>

        <!-- Lec 9: DP on Squares -->
        <tr>
            <td>Maximum Rectangle Area with all 1's|(DP-55)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Count Square Submatrices with All Ones|(DP-56)</td>
            <td>DP</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Implement TRIE | INSERT | SEARCH | STARTSWITH</td>
            <td>Trie</td>
            <td>Hard</td>
        </tr>

        <!-- Lec 2: Problems -->
        <tr>
            <td>Implement Trie - 2 (Prefix Tree)</td>
            <td>Trie</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Longest String with All Prefixes</td>
            <td>Trie</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Number of Distinct Substrings in a String</td>
            <td>Trie</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Bit PreRequisites for TRIE Problems</td>
            <td>Trie</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Maximum XOR of two numbers in an array</td>
            <td>Trie</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Maximum XOR With an Element From Array</td>
            <td>Trie</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Minimum number of bracket reversals needed to make an expression balanced</td>
            <td>H-String</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Count and say</td>
            <td>H-String</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Hashing In Strings | Theory</td>
            <td>H-String</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Rabin Karp</td>
            <td>H-String</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Z-Function</td>
            <td>H-String</td>
            <td>Easy</td>
        </tr>
        <tr>
            <td>KMP algo / LPS(pi) array</td>
            <td>H-String</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Shortest Palindrome</td>
            <td>H-String</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Longest happy prefix</td>
            <td>H-String</td>
            <td>Hard</td>
        </tr>
        <tr>
            <td>Count palindromic subsequence in given string</td>
            <td>H-String</td>
            <td>Hard</td>
        </tr>


    </table>
</body>

</html>